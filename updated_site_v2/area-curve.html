<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Area Under Curve Demo</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and Babel from CDNs -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <div class="max-w-5xl mx-auto p-4">
      <a href="index.html" class="text-purple-600 hover:underline">&larr; Back to Home</a>
      <h2 class="text-3xl font-bold text-center text-purple-700 my-6">Area Under a Curve</h2>
      <div id="root"></div>
    </div>
    <script type="text/babel" data-presets="typescript,react">
      // Destructure React hooks for convenience
      const { useEffect, useState, useMemo, useRef } = React;
      // Begin original source from area_under_a_curve_interactive_moving_svg_10_examples.jsx
      // Removed import line and replaced export default with plain function definition
      /* eslint-disable */
      /* eslint-disable react/prop-types */

      // Helper: clamp
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

      // Numerical helpers
      function trapIntegral(f, a, b, m = 5000) {
        const h = (b - a) / m;
        let sum = 0.5 * (f(a) + f(b));
        for (let i = 1; i < m; i++) sum += f(a + i * h);
        return sum * h;
      }

      // Pretty number
      const fmt = (x) => {
        if (!isFinite(x)) return "—";
        const ax = Math.abs(x);
        if (ax === 0) return "0";
        if (ax >= 10000) return x.toFixed(0);
        if (ax >= 1000) return x.toFixed(1);
        if (ax >= 100) return x.toFixed(2);
        if (ax >= 1) return x.toFixed(3);
        return x.toExponential(3);
      };

      // Examples library (10)
      const EXAMPLES = [
        {
          key: "ex1",
          title: "1) y = x on [0, 3]",
          type: "single",
          a: 0,
          b: 3,
          f: (x) => x,
          exactSigned: () => 0.5 * (3 ** 2),
          describe: [
            "Compute the area under y = x from x=0 to x=3.",
            "Signed area equals geometric area since y ≥ 0 on [0,3].",
          ],
        },
        {
          key: "ex2",
          title: "2) y = x^2 on [0, 2]",
          type: "single",
          a: 0,
          b: 2,
          f: (x) => x * x,
          exactSigned: () => (2 ** 3) / 3,
          describe: [
            "Compute the area under y = x² from x=0 to x=2.",
            "Signed area equals geometric area since y ≥ 0 on [0,2].",
          ],
        },
        {
          key: "ex3",
          title: "3) y = sin(x) on [0, π]",
          type: "single",
          a: 0,
          b: Math.PI,
          f: (x) => Math.sin(x),
          exactSigned: () => 2,
          describe: [
            "Compute the area under y = sin(x) from x=0 to x=π.",
            "Signed area equals geometric area since y ≥ 0 on [0,π].",
          ],
        },
        {
          key: "ex4",
          title: "4) y = cos(x) on [0, π/2]",
          type: "single",
          a: 0,
          b: Math.PI / 2,
          f: (x) => Math.cos(x),
          exactSigned: () => 1,
          describe: [
            "Compute the area under y = cos(x) from x=0 to x=π/2.",
            "Signed area equals geometric area since y ≥ 0 on [0,π/2].",
          ],
        },
        {
          key: "ex5",
          title: "5) y = e^x on [0, 1]",
          type: "single",
          a: 0,
          b: 1,
          f: (x) => Math.exp(x),
          exactSigned: () => Math.exp(1) - 1,
          describe: [
            "Compute the area under y = e^x from x=0 to x=1.",
            "Signed area equals geometric area since y ≥ 0 on [0,1].",
          ],
        },
        {
          key: "ex6",
          title: "6) y = cos(x) on [0, 2π] (signed)",
          type: "single",
          a: 0,
          b: 2 * Math.PI,
          f: (x) => Math.cos(x),
          exactSigned: () => 0,
          describe: [
            "Compute the signed area under y = cos(x) from x=0 to 2π.",
            "Since cos(x) is positive and negative equally, signed area is 0.",
          ],
        },
        {
          key: "ex7",
          title: "7) y = sin(x) on [0, 2π] (signed)",
          type: "single",
          a: 0,
          b: 2 * Math.PI,
          f: (x) => Math.sin(x),
          exactSigned: () => 0,
          describe: [
            "Compute the signed area under y = sin(x) from x=0 to 2π.",
            "Positive area on [0,π] cancels with negative area on [π,2π].",
          ],
        },
        {
          key: "ex8",
          title: "8) y = 2x on [-1, 1] (signed)",
          type: "single",
          a: -1,
          b: 1,
          f: (x) => 2 * x,
          exactSigned: () => 0,
          describe: [
            "Compute the signed area under y = 2x from x=-1 to x=1.",
            "Positive area on [0,1] cancels with negative area on [-1,0].",
          ],
        },
        {
          key: "ex9",
          title: "9) y = x^3 on [-1, 1] (signed)",
          type: "single",
          a: -1,
          b: 1,
          f: (x) => x ** 3,
          exactSigned: () => 0,
          describe: [
            "Compute the signed area under y = x^3 from x=-1 to x=1.",
            "Odd functions have symmetrical positive and negative areas.",
          ],
        },
        {
          key: "ex10",
          title: "10) y = x^2 and y = x on [0, 2] (between)",
          type: "between",
          a: 0,
          b: 2,
          f1: (x) => x ** 2,
          f2: (x) => x,
          exactSigned: () => (2 ** 3) / 3 - 0.5 * (2 ** 2),
          describe: [
            "Compute the area between y = x^2 and y = x from x=0 to x=2.",
            "Subtract the lower curve from the upper to get area between.",
          ],
        },
      ];

      function AreaUnderCurveCanvas() {
        const [exIdx, setExIdx] = useState(0);
        const ex = EXAMPLES[exIdx];
        const [numRect, setNumRect] = useState(10);
        const [method, setMethod] = useState("mid");
        const canvasRef = useRef(null);

        // Compute signed area or between curves
        const exact = useMemo(() => {
          if (ex.type === "single") return ex.exactSigned();
          // between curves: integrate f2 - f1
          return trapIntegral((x) => ex.f2(x) - ex.f1(x), ex.a, ex.b);
        }, [ex]);

        // Draw the function and rectangles
        useEffect(() => {
          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");
          const width = canvas.width;
          const height = canvas.height;

          // Clear
          ctx.clearRect(0, 0, width, height);

          // Draw axes
          ctx.strokeStyle = "#888";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, height / 2);
          ctx.lineTo(width, height / 2);
          ctx.moveTo(width / 2, 0);
          ctx.lineTo(width / 2, height);
          ctx.stroke();

          // Convert x,y to canvas coords
          const xToCanvas = (x) => ((x - ex.a) / (ex.b - ex.a)) * width;
          const yMax = Math.max(...[0, ...Array(100).fill().map((_, i) => Math.abs(ex.type === "single" ? ex.f(ex.a + (i / 99) * (ex.b - ex.a)) : Math.max(ex.f1(ex.a + (i / 99) * (ex.b - ex.a)), ex.f2(ex.a + (i / 99) * (ex.b - ex.a)))))]);
          const yToCanvas = (y) => height / 2 - (y / (yMax * 1.2)) * (height / 2);

          // Draw rectangles
          const n = numRect;
          for (let i = 0; i < n; i++) {
            let x0 = ex.a + (i / n) * (ex.b - ex.a);
            let x1 = ex.a + ((i + 1) / n) * (ex.b - ex.a);
            let xm;
            if (method === "left") xm = x0;
            else if (method === "right") xm = x1;
            else xm = (x0 + x1) / 2;
            let yRect;
            if (ex.type === "single") yRect = ex.f(xm);
            else yRect = ex.f2(xm) - ex.f1(xm);
            const rectHeight = yRect;
            const rectTop = rectHeight >= 0 ? yToCanvas(rectHeight) : yToCanvas(0);
            const rectBottom = rectHeight >= 0 ? yToCanvas(0) : yToCanvas(rectHeight);
            const rectWidth = xToCanvas(x1) - xToCanvas(x0);
            ctx.fillStyle = rectHeight >= 0 ? "rgba(96,165,250,0.4)" : "rgba(239,68,68,0.4)";
            ctx.fillRect(xToCanvas(x0), rectTop, rectWidth, rectBottom - rectTop);
          }

          // Draw function curve(s)
          ctx.strokeStyle = "#4B5563";
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i <= 100; i++) {
            const x = ex.a + (i / 100) * (ex.b - ex.a);
            const y = ex.type === "single" ? ex.f(x) : ex.f1(x);
            const cx = xToCanvas(x);
            const cy = yToCanvas(y);
            if (i === 0) ctx.moveTo(cx, cy);
            else ctx.lineTo(cx, cy);
          }
          ctx.stroke();
          if (ex.type === "between") {
            ctx.strokeStyle = "#D97706";
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
              const x = ex.a + (i / 100) * (ex.b - ex.a);
              const y = ex.f2(x);
              const cx = xToCanvas(x);
              const cy = yToCanvas(y);
              if (i === 0) ctx.moveTo(cx, cy);
              else ctx.lineTo(cx, cy);
            }
            ctx.stroke();
          }
        }, [ex, numRect, method]);

        return (
          <div className="space-y-6">
            <div className="flex flex-col md:flex-row md:space-x-6">
              <div className="md:w-3/5">
                <canvas ref={canvasRef} width={600} height={400} className="w-full border rounded"></canvas>
              </div>
              <div className="md:w-2/5 space-y-4 mt-4 md:mt-0">
                <div>
                  <label className="block font-medium mb-1">Example</label>
                  <select
                    value={exIdx}
                    onChange={(e) => setExIdx(parseInt(e.target.value))}
                    className="w-full border-gray-300 rounded p-2"
                  >
                    {EXAMPLES.map((ex, idx) => (
                      <option key={ex.key} value={idx}>
                        {ex.title}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="block font-medium mb-1">Number of Rectangles: {numRect}</label>
                  <input
                    type="range"
                    min="1"
                    max="50"
                    value={numRect}
                    onChange={(e) => setNumRect(parseInt(e.target.value))}
                    className="w-full"
                  />
                </div>
                <div>
                  <label className="block font-medium mb-1">Method</label>
                  <select
                    value={method}
                    onChange={(e) => setMethod(e.target.value)}
                    className="w-full border-gray-300 rounded p-2"
                  >
                    <option value="left">Left Sum</option>
                    <option value="mid">Midpoint Sum</option>
                    <option value="right">Right Sum</option>
                  </select>
                </div>
                <div className="p-4 rounded bg-gray-100">
                  <p className="font-semibold mb-2">Exact Signed Area:</p>
                  <p className="text-xl">{fmt(exact)}</p>
                </div>
              </div>
            </div>
            <div className="mt-6">
              <h4 className="text-xl font-semibold mb-2">Problem Description</h4>
              <ul className="list-disc pl-6 space-y-1">
                {ex.describe.map((d, i) => (
                  <li key={i}>{d}</li>
                ))}
              </ul>
            </div>
          </div>
        );
      }

      // Render the demo
      ReactDOM.render(<AreaUnderCurveCanvas />, document.getElementById("root"));
    </script>
  </body>
</html>